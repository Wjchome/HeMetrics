# 响应类型处理说明

## 问题

**是的，需要提前知道响应类型！**

当服务器返回响应时，客户端需要知道如何反序列化响应数据。这与 Go 服务器的实现方式完全一致。

## Go 服务器的实现方式

在 Go 客户端中，发送请求时需要提供两个函数：

```go
client.SendReq(
    moduleId,
    routerId,
    request,
    func(ctx rsp_ctx.Context, data any) {
        // 响应回调 - 接收反序列化后的对象
        rsp := data.(*TestRsp)
    },
    func() any {
        // 创建响应对象的函数 - 用于反序列化
        return &TestRsp{}
    },
)
```

服务器收到响应后：
1. 通过 `reqId` 找到对应的 `RspHandler`
2. 调用 `handler.newBodyFunc()` 创建响应对象
3. 使用 `serializer.Unmarshal()` 反序列化数据到响应对象
4. 调用 `handler.rspCallback()` 传递反序列化后的对象

## Unity C# 的实现方式

Unity 客户端提供了两种方式：

### 方式1：类型化API（推荐，类似Go）

```csharp
// 发送请求时指定响应类型
netManager.SendRequest<TestRsp>(
    moduleId: 1,
    routerId: 1,
    request: testReq,  // 请求对象（自动序列化）
    onResponse: (testRsp) => {
        // 响应已经自动反序列化为TestRsp对象
        Debug.Log($"Result: {testRsp.Result}");
    }
);
```

**优点：**
- 类型安全
- 自动序列化/反序列化
- 代码简洁
- 与Go实现一致

### 方式2：原始字节数组API（兼容旧代码）

```csharp
// 手动序列化请求
byte[] messageBody = testReq.ToByteArray();

// 发送请求
netManager.SendRequest(
    moduleId: 1,
    routerId: 1,
    messageBody: messageBody,
    onResponse: (responseBytes) => {
        // 需要手动反序列化
        var testRsp = TestRsp.Parser.ParseFrom(responseBytes);
        Debug.Log($"Result: {testRsp.Result}");
    }
);
```

**适用场景：**
- 需要自定义序列化逻辑
- 兼容旧代码

## 工作原理

### 类型化API的工作流程

1. **发送请求时**：
   ```csharp
   SendRequest<TestRsp>(..., request, onResponse)
   ```
   - 自动序列化 `request` 对象
   - 注册 `ResponseHandler`，包含：
     - `ResponseType = typeof(TestRsp)` - 响应类型
     - `NewBodyFunc = () => new TestRsp()` - 创建响应对象
     - `Callback = (rsp) => onResponse((TestRsp)rsp)` - 回调函数

2. **收到响应时**：
   ```csharp
   ParseResponse(packetData)
   ```
   - 通过 `reqId` 找到对应的 `ResponseHandler`
   - 使用反射获取 `TestRsp.Parser`
   - 调用 `Parser.ParseFrom(messageBody)` 反序列化
   - 调用回调函数，传递反序列化后的对象

### 与Go实现的对应关系

| Go 实现 | Unity C# 实现 |
|---------|--------------|
| `handler.newBodyFunc()` | `ResponseHandler.NewBodyFunc()` |
| `serializer.Unmarshal()` | `Parser.ParseFrom()` |
| `handler.rspCallback()` | `ResponseHandler.Callback()` |
| `RspHandler` | `ResponseHandler` |

## 为什么需要提前知道类型？

1. **反序列化需要类型信息**
   - Protobuf 需要知道目标类型才能正确解析字节数组
   - 不同的消息类型有不同的字段结构

2. **类型安全**
   - 编译时就能检查类型错误
   - 避免运行时类型转换错误

3. **代码简洁**
   - 自动处理序列化/反序列化
   - 回调直接接收强类型对象

## 示例对比

### Go 版本
```go
client.SendReq(
    common.TestModuleId,
    common.TestRouterId,
    testReq,
    func(ctx rsp_ctx.Context, data any) {
        rsp := data.(*testpb.TestRsp)  // 类型断言
        logx.Infof("Result: %s", rsp.Result)
    },
    func() any {
        return &testpb.TestRsp{}  // 创建响应对象
    },
)
```

### Unity C# 版本（类型化）
```csharp
netManager.SendRequest<TestRsp>(
    moduleId: 1,
    routerId: 1,
    request: testReq,
    onResponse: (testRsp) => {
        // 直接使用强类型对象，无需类型转换
        Debug.Log($"Result: {testRsp.Result}");
    }
);
```

## 注意事项

1. **响应类型必须匹配**
   - `SendRequest<TestRsp>` 必须对应服务器返回的 `TestRsp`
   - 类型不匹配会导致反序列化失败

2. **泛型约束**
   - 响应类型必须实现 `IMessage` 接口
   - 必须有无参构造函数（`new()` 约束）

3. **线程安全**
   - 响应回调在主线程执行（通过 `Enqueue`）
   - 可以安全地访问 Unity API

## 总结

**是的，需要提前知道响应类型**，这是 Protobuf 反序列化的要求。Unity 客户端通过泛型 API 让这个过程变得简单和类型安全，与 Go 服务器的实现方式保持一致。


